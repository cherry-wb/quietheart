http://hi.baidu.com/%E5%8D%81%E4%B8%83%E6%97%A5%E6%9C%88/blog/item/35e14d2b5af0d0f6e7cd409a.html
利用map文件进行调试[转贴]
2010-05-28 10:53
在VC中，我们可以利用出现程序崩溃时VC的自动跳转，定位到出错代码行。但在大量的压力测试时，尤其是多线程测试时，同时出现几十个错，这时VC本身的出错跳转往往会失灵。

在这里我们介绍一种辅助查找程序崩溃代码行的好方法，它的核心就是利用编译时生成MAP文件中的信息来定位代码行。下面就开始我们的介绍。

首先我们必须生成程序的MAP文件。那么什么是 MAP 文件呢？简单地讲， MAP 文件是程序的全局符号、源文件和代码行号信息的唯一的文本表示方法，是整个程序工程信息的静态文本。它可以在任何地方、任何时候使用，不需要有额外的程序 进行支持，仅仅通过一个文本阅读工具如Ultra Edit就可以打开了。而且，这是唯一能找出程序崩溃代码行的救星。

那么我们应该如何生成 MAP文件呢？
在 VC 中，我们可以按下 Alt+F7，打开“Project Settings”选项页，选择 C/C++ 选项卡，并在最下面的 Project Options 里面输入：/Zd ，然后要选择 Link 选项卡，选中“Generate mapfile”复选框，并在最下面的 Project Options 里面输入：/mapinfo:lines，表示生成 MAP 文件时，加入行信息。最后按下 F7 来编译生成 EXE 可执行文件和 MAP 文件，此时可以在工程的Debug目录下找到刚刚生成的MAP文件，文件名为“工程名.map”。

通过上面的步骤，已经得到了 MAP 文件，那么我们该如何利用它呢？让我们从一个简单的实例入手，一步一步演示使用MAP文件定位程序崩溃行的过程。

首先假设我们的VC工程中有下面这个文件：
//*****************************************************
// 程序名称：演示如何通过崩溃地址找出源代码的出错行
// 本程序会产生“除0错误”，所以会导致
// 程序崩溃，弹出“非法操作”对话框。
//******************************************************
#include
int crashtest(int a,int b)
{
int c;
c = a/b;
return c;
}

void main(void)
{
int a = 30;   int b = 0;
int ret;
printf("let's begin crash test...\n");
ret = crashtest(a,b);
}

很显然本程序有“除0错误”，在 Debug 方式下编译，运行时会产生“非法操作”。我们记录下产生崩溃的地址——在我的机器上是 0x0040102f 。这个在不同的机器上可能地址不同，但记下这个地址我们下面将要使用。


我们打开它的 MAP 文件：（这里列出我们比较关心的内容，其他的就略过了）
abort（工程名）
Timestamp is 3ef16533 (Thu Jun 19 15:24:35 2003)
Preferred load address is 00400000

Start　　　　Length　　　　Name　　　　　　　　Class
0001:00000000　0001081dH .text　　　　　　　　CODE
0002:00000000　000013baH .rdata 　　　　　　　DATA
0002:000013ba　00000000H .edata　　　　　　　　DATA
0003:00000000　00000104H .CRT$XCA　　　　　　　DATA
0003:00000104　00000104H .CRT$XCZ　　　　　　　DATA
………

Address Publics by Value Rva+Base Lib:Object

0001:00000020 ?crashtest@@YAHHH@Z 00401020 f main.obj
0001:0000003c _main 0040103c f main.obj
0001:000000b0 _printf 004010b0 f LIBCD:printf.obj
0001:00000130 __chkesp 00401130 f LIBCD:chkesp.obj
0001:00000170 _mainCRTStartup 00401170 f LIBCD:crt0.obj
0001:000002a0 __amsg_exit 004012a0 f LIBCD:crt0.obj
0001:00000300 __stbuf 00401300 f LIBCD:_sftbuf.obj
0001:00000460 __ftbuf 00401460 f LIBCD:_sftbuf.obj
0001:00000520 __output 00401520 f LIBCD:output.obj
0001:000013c0 ___initstdio 004023c0 f LIBCD:_file.obj
0001:000014f0 ___endstdio 004024f0 f LIBCD:_file.obj
0001:00001510 __CrtDbgBreak 00402510 f LIBCD:dbgrpt.obj
0001:00001520 __CrtSetReportMode 00402520 f LIBCD:dbgrpt.obj
0001:00001580 __CrtSetReportFile 00402580 f LIBCD:dbgrpt.obj
0001:00001600 __CrtSetReportHook 00402600 f LIBCD:dbgrpt.obj
0001:00001620 __CrtDbgReport 00402620 f LIBCD:dbgrpt.obj
如果仔细浏览 Rva+Base 这栏，我们可以发现第一个比崩溃地址 0x0040102f 大的函数地址是 0x0040103c ，所以在 0x0040103c 这个地址之前的那个入口就是产生崩溃的函数，也就是这行：
0001:00000020 ?crashtest@@YAHHH@Z 00401020 f main.obj

因此，发生崩溃的函数就是 ?crashtest@@YAHHH@Z，所有以问号开头的函数名称都是 C++ 修饰的名称。所以在我们的源程序中，这个发生崩溃的函数就是crashtest ().

现在我们便轻而易举地知道了发生崩溃的函数名称。把它记下来，然后我们将要直接定位发生崩溃的代码行了。我们注意 MAP 文件的最后部分——代码行信息（Line numbers information），它是以这样的形式显示的：
Line numbers for .\Debug\main.obj(D:\我的工作\技术\出异常例子abort\main.cpp) segment .text

12 0001:00000020 14 0001:0000002b 15 0001:00000035 16 0001:00000038
19 0001:0000003c 20 0001:00000057 21 0001:0000005e 23 0001:00000065
24 0001:00000072 25 0001:00000085

第一个数字代表在源代码中的代码行号，第二个数是该代码行在所属的代码段中的偏移量。如果要查找代码行号，需要使用下面的公式做一些十六进制的减法运算：
崩溃行偏移 = 崩溃地址（Crash Address）－ 基地址（ImageBase Address）－ 0x1000

为什么要这样做呢？因为我们得到的崩溃地址都是由 偏移地址（Rva）+ 基地址（Base）得来的，所以在计算行号的时候要把基地址减去。一般情况下，基地址的值是 0x00400000 。另外，由于一般的 PE 文件的代码段都是从 0x1000 偏移开始的，所以也必须减去 0x1000 。

所以我们的：崩溃行偏移 = 0x0040102f - 0x00400000 - 0x1000 = 0x2f

我们在MAP 文件的中的代码行信息里查找不超过计算结果0x2f，但却最接近的数。发现是 main.cpp 文件中的：14 0001:0000002b

也就意味着在源代码中的第 14 行！让我们来看看源代码，注意注释行和空行也要计算在内，程序的第14行为：c = a/b;
果然就是第 14 行啊，它发生了“除0异常”！


方法已经介绍完了，从今以后，我们就可以精确地定位到源代码中的崩溃行，而且只要编译器可以生成 MAP 文件，无论在WIN平台还是UNIX平台，本方法都是适用的。

本文我们只是列举了一个非常简单的“除0异常”例子，使用MAP文件的效力或许还不十分明显。但相信在我们的大型应用系统调试中，使用MAP文件的辅助 方法来快速定位发生程序崩溃的函数以及代码行，将会为我们的程序调试工作节省大量时间和精力，提高我们的调试质量。我们甚至可以要求远地用户直接提供程序 崩溃的地址，然后就可以在自己机器上利用MAP文件静态地找到出错的那行，并在程序中进行相应修正了。
